[{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\_shared\\cors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\admin-users-with-metrics\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\claude-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\external-knowledge-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\index.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\+.","line":528,"column":17,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":528,"endColumn":18,"suggestions":[{"messageId":"removeEscape","fix":{"range":[18862,18863],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[18862,18862],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\*.","line":528,"column":21,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":528,"endColumn":22,"suggestions":[{"messageId":"removeEscape","fix":{"range":[18866,18867],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[18866,18866],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":528,"column":23,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":528,"endColumn":24,"suggestions":[{"messageId":"removeEscape","fix":{"range":[18868,18869],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[18868,18868],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\+.","line":592,"column":34,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":592,"endColumn":35,"suggestions":[{"messageId":"removeEscape","fix":{"range":[21215,21216],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[21215,21215],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\*.","line":592,"column":38,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":592,"endColumn":39,"suggestions":[{"messageId":"removeEscape","fix":{"range":[21219,21220],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[21219,21219],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":592,"column":40,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":592,"endColumn":41,"suggestions":[{"messageId":"removeEscape","fix":{"range":[21221,21222],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[21221,21221],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\+.","line":593,"column":48,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":593,"endColumn":49,"suggestions":[{"messageId":"removeEscape","fix":{"range":[21439,21440],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[21439,21439],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\*.","line":593,"column":52,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":593,"endColumn":53,"suggestions":[{"messageId":"removeEscape","fix":{"range":[21443,21444],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[21443,21443],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":593,"column":54,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":593,"endColumn":55,"suggestions":[{"messageId":"removeEscape","fix":{"range":[21445,21446],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[21445,21445],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import \"https://deno.land/x/xhr@0.1.0/mod.ts\";\r\nimport { serve } from \"https://deno.land/std@0.168.0/http/server.ts\";\r\nimport { corsHeaders, SOCRATIC_BLUEPRINT_V42, GEMINI_MODEL, MAX_TOKENS, TIMEOUT_MS, BLUEPRINT_VERSION } from './constants.ts';\r\nimport { buildSimplePrompt, PromptType, SimplePromptContext } from './simple-prompt-selector.ts';\r\nimport type { ChatRequest } from './types.ts';\r\n\r\n// AI Study Coach v7.0 - Google Gemini Implementation\r\nconst geminiApiKey = Deno.env.get('GOOGLE_GEMINI_API_KEY');\r\n\r\n// Log API key availability\r\nconsole.log('üîê Gemini API Key Status:', {\r\n  hasKey: !!geminiApiKey,\r\n  keyLength: geminiApiKey?.length || 0,\r\n  keyPrefix: geminiApiKey?.substring(0, 10) + '...' || 'N/A',\r\n  isValidFormat: geminiApiKey?.length > 30 || false\r\n});\r\n\r\nserve(async (req) => {\r\n  const startTime = performance.now();\r\n  \r\n  // Add basic connectivity test\r\n  console.log('üöÄ AI Study Chat function invoked:', {\r\n    method: req.method,\r\n    url: req.url,\r\n    timestamp: new Date().toISOString(),\r\n    hasGeminiKey: !!geminiApiKey\r\n  });\r\n  \r\n  if (req.method === 'OPTIONS') {\r\n    console.log('‚úÖ CORS preflight request handled');\r\n    return new Response(null, { headers: corsHeaders });\r\n  }\r\n\r\n  // Add health check endpoint\r\n  if (req.method === 'GET') {\r\n    console.log('üîç Health check requested');\r\n    return new Response(JSON.stringify({ \r\n      status: 'healthy', \r\n      timestamp: new Date().toISOString(),\r\n      blueprintVersion: BLUEPRINT_VERSION,\r\n      hasGeminiKey: !!geminiApiKey,\r\n      timeout: TIMEOUT_MS\r\n    }), {\r\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' }\r\n    });\r\n  }\r\n\r\n  try {\r\n    const requestParseStart = performance.now();\r\n    const requestBody = await req.json().catch(() => ({}));\r\n    const {\r\n      message,\r\n      userId,\r\n      sessionId,\r\n      promptType,\r\n      contextData = {},\r\n      chatMode = 'general',\r\n      voiceActive = false,\r\n      clientHistory = [],\r\n      originalTopic,\r\n      lessonContext\r\n    } = requestBody;\r\n\r\n    const requestParseTime = performance.now() - requestParseStart;\r\n\r\n    // Extract or detect original topic from conversation\r\n    const detectedOriginalTopic = originalTopic || extractOriginalTopic(clientHistory, message);\r\n    \r\n    console.log('üéØ Gemini AI Processing (Enhanced Timing):', {\r\n      messageLength: message?.length || 0,\r\n      userId: userId?.substring(0, 8) + '...' || 'unknown',\r\n      sessionId: sessionId?.substring(0, 8) + '...' || 'none',\r\n      promptType: promptType || 'auto-detected',\r\n      chatMode,\r\n      voiceActive,\r\n      contextKeys: Object.keys(contextData),\r\n      historyLength: clientHistory?.length || 0,\r\n      originalTopic: detectedOriginalTopic || 'none',\r\n      hasValidRequest: !!(message && userId),\r\n      requestParseTime: `${requestParseTime.toFixed(2)}ms`,\r\n      totalTimeElapsed: `${(performance.now() - startTime).toFixed(2)}ms`\r\n    });\r\n\r\n    // Enhanced validation with detailed error responses\r\n    if (!message || typeof message !== 'string') {\r\n      console.error('‚ùå Invalid message parameter:', { message, type: typeof message });\r\n      return new Response(\r\n        JSON.stringify({ \r\n          error: 'Valid message string is required',\r\n          received: { message: typeof message, length: message?.length }\r\n        }),\r\n        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n\r\n    if (!userId || typeof userId !== 'string') {\r\n      console.error('‚ùå Invalid userId parameter:', { userId, type: typeof userId });\r\n      return new Response(\r\n        JSON.stringify({ \r\n          error: 'Valid userId string is required',\r\n          received: { userId: typeof userId }\r\n        }),\r\n        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n\r\n    // Auto-detect promptType if missing\r\n    let detectedPromptType = promptType;\r\n    if (!promptType || typeof promptType !== 'string') {\r\n      console.log('üîç Auto-detecting promptType from message and history...');\r\n      detectedPromptType = autoDetectPromptType(message, clientHistory);\r\n      console.log(`üéØ Auto-detected promptType: ${detectedPromptType}`);\r\n    }\r\n\r\n    // Handle missing API key gracefully\r\n    if (!geminiApiKey) {\r\n      console.log('‚ö†Ô∏è  GOOGLE_GEMINI_API_KEY not configured - using fallback response');\r\n      const fallbackResponse = getContextualResponse(message, chatMode, 'no_api_key');\r\n      \r\n      return new Response(\r\n        JSON.stringify({ \r\n          response: fallbackResponse,\r\n          source: 'no_api_key_fallback',\r\n          blueprintVersion: BLUEPRINT_VERSION,\r\n          debug: {\r\n            hasMessage: !!message,\r\n            messageLength: message?.length || 0,\r\n            chatMode,\r\n            functionWorking: true\r\n          }\r\n        }),\r\n        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n\r\n    // Test mode: If message starts with \"test\", return immediately without API call\r\n    if (message.toLowerCase().startsWith('test')) {\r\n      console.log('üß™ Test mode activated - skipping API call');\r\n      return new Response(\r\n        JSON.stringify({ \r\n          response: `Test successful! I received your message: \"${message}\". The AI function is working properly. Try asking a real question now!`,\r\n          source: 'test_mode',\r\n          blueprintVersion: BLUEPRINT_VERSION,\r\n          debug: {\r\n            hasGeminiKey: !!geminiApiKey,\r\n            functionWorking: true,\r\n            processingTime: `${(performance.now() - startTime).toFixed(2)}ms`\r\n          }\r\n        }),\r\n        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n\r\n    // Build conversation history summary\r\n    const conversationSummary = buildConversationSummary(clientHistory);\r\n    \r\n    // Build simple prompt using Blueprint v4.2 system\r\n    const promptContext: SimplePromptContext = {\r\n      chatMode,\r\n      voiceActive,\r\n      userInput: message,\r\n      quizTopic: contextData.quizTopic,\r\n      teachingHistory: contextData.teachingHistory,\r\n      incorrectCount: contextData.incorrectCount,\r\n      originalTopic: detectedOriginalTopic,\r\n      conversationHistory: conversationSummary,\r\n      lessonContent: lessonContext?.lessonContent,\r\n      lessonTitle: lessonContext?.lessonTitle,\r\n      courseId: lessonContext?.courseId,\r\n      lessonId: lessonContext?.lessonId,\r\n    };\r\n\r\n    const contextPrompt = buildSimplePrompt(detectedPromptType as PromptType, promptContext);\r\n\r\n    console.log('üìù Simple prompt generated:', { \r\n      type: detectedPromptType, \r\n      length: contextPrompt.length,\r\n      context: {\r\n        hasUserInput: !!message,\r\n        voiceActive,\r\n        chatMode,\r\n        contextDataKeys: Object.keys(contextData)\r\n      }\r\n    });\r\n\r\n    // Call Google Gemini API with Socratic Blueprint v4.4 and retry logic\r\n    const geminiRequestStart = performance.now();\r\n    \r\n    console.log('üì° Making Google Gemini API request (with timeout and retry):', {\r\n      model: GEMINI_MODEL,\r\n      maxTokens: MAX_TOKENS,\r\n      promptLength: contextPrompt.length,\r\n      apiUrl: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent',\r\n      timeElapsed: `${(performance.now() - startTime).toFixed(2)}ms`\r\n    });\r\n    \r\n    // Retry configuration\r\n    const maxRetries = 2;\r\n    let lastError = null;\r\n    \r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      console.log(`üîÑ Gemini API attempt ${attempt}/${maxRetries}`);\r\n      \r\n      // Add timeout to Gemini API call\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => {\r\n        console.error(`‚è∞ Gemini API timeout after ${TIMEOUT_MS/1000} seconds (attempt ${attempt})`);\r\n        controller.abort();\r\n      }, TIMEOUT_MS);\r\n      \r\n      try {\r\n        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${geminiApiKey}`, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json'\r\n          },\r\n          body: JSON.stringify({\r\n            contents: [{\r\n              parts: [{ text: contextPrompt }]\r\n            }],\r\n            systemInstruction: {\r\n              parts: [{ text: SOCRATIC_BLUEPRINT_V42 }]\r\n            },\r\n            generationConfig: {\r\n              maxOutputTokens: MAX_TOKENS,\r\n              temperature: 0.7,\r\n              topP: 0.9,\r\n              topK: 40\r\n            },\r\n            safetySettings: [\r\n              {\r\n                category: \"HARM_CATEGORY_HARASSMENT\",\r\n                threshold: \"BLOCK_MEDIUM_AND_ABOVE\"\r\n              },\r\n              {\r\n                category: \"HARM_CATEGORY_HATE_SPEECH\", \r\n                threshold: \"BLOCK_MEDIUM_AND_ABOVE\"\r\n              },\r\n              {\r\n                category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\r\n                threshold: \"BLOCK_MEDIUM_AND_ABOVE\"\r\n              },\r\n              {\r\n                category: \"HARM_CATEGORY_DANGEROUS_CONTENT\",\r\n                threshold: \"BLOCK_MEDIUM_AND_ABOVE\"\r\n              }\r\n            ]\r\n          }),\r\n          signal: controller.signal\r\n        });\r\n\r\n        clearTimeout(timeoutId);\r\n        const geminiRequestTime = performance.now() - geminiRequestStart;\r\n        \r\n        console.log('üì° Google Gemini API response received:', {\r\n          status: response.status,\r\n          attempt,\r\n          requestTime: `${geminiRequestTime.toFixed(2)}ms`,\r\n          totalTimeElapsed: `${(performance.now() - startTime).toFixed(2)}ms`\r\n        });\r\n\r\n        if (!response.ok) {\r\n          const errorText = await response.text();\r\n          console.error(`‚ùå Gemini API error (attempt ${attempt}):`, {\r\n            status: response.status,\r\n            statusText: response.statusText,\r\n            errorBody: errorText,\r\n            attempt,\r\n            willRetry: attempt < maxRetries\r\n          });\r\n          \r\n          lastError = new Error(`API Error ${response.status}: ${response.statusText}`);\r\n          \r\n          // If this is the last attempt, provide contextual response\r\n          if (attempt === maxRetries) {\r\n            const contextualResponse = getContextualResponse(message, chatMode, 'api_error');\r\n            \r\n            return new Response(JSON.stringify({\r\n              response: contextualResponse,\r\n              source: 'api_error_fallback',\r\n              blueprintVersion: BLUEPRINT_VERSION,\r\n              error: `API Error ${response.status}: ${response.statusText}`,\r\n              apiKeyStatus: {\r\n                hasKey: !!geminiApiKey,\r\n                keyLength: geminiApiKey?.length || 0,\r\n                isValidFormat: geminiApiKey?.length > 30 || false\r\n              }\r\n            }), {\r\n              status: 200,\r\n              headers: { ...corsHeaders, 'Content-Type': 'application/json' }\r\n            });\r\n          }\r\n          \r\n          // Wait before retry (exponential backoff)\r\n          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\r\n          continue; // Try next attempt\r\n        }\r\n\r\n        // Success! Process the response\r\n        const jsonParseStart = performance.now();\r\n        const data = await response.json();\r\n        const jsonParseTime = performance.now() - jsonParseStart;\r\n        \r\n        const aiResponse = data?.candidates?.[0]?.content?.parts?.[0]?.text || 'I apologize, but I encountered an issue processing your request. Please try again.';\r\n\r\n        const totalTime = performance.now() - startTime;\r\n        console.log('‚úÖ Gemini response generated successfully:', {\r\n          totalProcessingTime: `${totalTime.toFixed(2)}ms`,\r\n          jsonParseTime: `${jsonParseTime.toFixed(2)}ms`,\r\n          responseLength: aiResponse.length,\r\n          attempt,\r\n          success: true\r\n        });\r\n\r\n        return new Response(JSON.stringify({\r\n          response: aiResponse,\r\n          source: 'google_gemini_v4.4',\r\n          blueprintVersion: BLUEPRINT_VERSION,\r\n          metadata: {\r\n            model: GEMINI_MODEL,\r\n            promptType: detectedPromptType,\r\n            chatMode,\r\n            voiceActive,\r\n            contextProcessed: Object.keys(contextData),\r\n            historyLength: clientHistory?.length || 0,\r\n            processingTime: `${totalTime.toFixed(2)}ms`,\r\n            attempt,\r\n            retryLogic: 'enabled'\r\n          }\r\n        }), {\r\n          headers: { ...corsHeaders, 'Content-Type': 'application/json' }\r\n        });\r\n\r\n      } catch (fetchError) {\r\n        clearTimeout(timeoutId);\r\n        \r\n        if (fetchError.name === 'AbortError') {\r\n          console.error(`‚è∞ Gemini API request timed out after ${TIMEOUT_MS/1000} seconds (attempt ${attempt})`, {\r\n            message: message.substring(0, 100),\r\n            chatMode,\r\n            promptType: detectedPromptType,\r\n            totalTime: `${(performance.now() - startTime).toFixed(2)}ms`,\r\n            attempt,\r\n            willRetry: attempt < maxRetries\r\n          });\r\n          \r\n          lastError = new Error(`Request timed out after ${TIMEOUT_MS/1000} seconds`);\r\n          \r\n          // If this is the last attempt, return timeout response\r\n          if (attempt === maxRetries) {\r\n            const timeoutResponse = getContextualResponse(message, chatMode, 'timeout');\r\n            \r\n            return new Response(JSON.stringify({\r\n              response: timeoutResponse,\r\n              source: 'timeout_fallback',\r\n              blueprintVersion: BLUEPRINT_VERSION,\r\n              error: `Request timed out after ${TIMEOUT_MS/1000} seconds`,\r\n              retryAdvice: 'Please try rephrasing your question more concisely or try again in a moment.',\r\n              attemptsExhausted: maxRetries\r\n            }), {\r\n              status: 200,\r\n              headers: { ...corsHeaders, 'Content-Type': 'application/json' }\r\n            });\r\n          }\r\n          \r\n          // Wait before retry\r\n          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\r\n          continue; // Try next attempt\r\n        }\r\n        \r\n        // Other fetch errors\r\n        console.error(`‚ùå Fetch error (attempt ${attempt}):`, fetchError);\r\n        lastError = fetchError;\r\n        \r\n        if (attempt === maxRetries) {\r\n          throw fetchError; // Let it fall through to main error handler\r\n        }\r\n        \r\n        // Wait before retry\r\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\r\n        continue; // Try next attempt\r\n      }\r\n    }\r\n    \r\n    // This should never be reached, but just in case\r\n    throw lastError || new Error('All retry attempts failed');\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå Error in ai-study-chat function:', error);\r\n    \r\n    // Enhanced error logging\r\n    console.error('‚ùå Full error details:', {\r\n      message: error.message,\r\n      stack: error.stack,\r\n      name: error.name,\r\n      chatMode: chatMode || 'general',\r\n      promptType,\r\n      messageLength: message?.length || 0\r\n    });\r\n    \r\n    // Provide contextual error response\r\n    const errorResponse = getContextualResponse(message, chatMode || 'general', 'system_error');\r\n    \r\n    return new Response(JSON.stringify({\r\n      response: errorResponse,\r\n      source: 'system_error_fallback',\r\n      blueprintVersion: BLUEPRINT_VERSION,\r\n      error: error.message\r\n    }), {\r\n      status: 200, // Return 200 to avoid client-side errors\r\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' }\r\n    });\r\n  }\r\n});\r\n\r\n// Auto-detect prompt type based on message content and conversation history\r\nfunction autoDetectPromptType(message: string, history: any[]): string {\r\n  const trimmed = message.toLowerCase().trim();\r\n  \r\n  // Direct answer command\r\n  if (trimmed.startsWith('/answer')) {\r\n    return 'direct_answer';\r\n  }\r\n  \r\n  // Session ending signals\r\n  if (isSessionEndingSignal(trimmed)) {\r\n    return 'end_session';\r\n  }\r\n  \r\n  // Topic transition requests\r\n  if (isTopicTransitionRequest(trimmed)) {\r\n    return 'topic_transition';\r\n  }\r\n  \r\n  // Gratitude expressions (when not followed by new topic)\r\n  if (isGratitudeExpression(trimmed) && !isTopicTransitionRequest(trimmed)) {\r\n    return 'acknowledgment';\r\n  }\r\n  \r\n  // Quiz requests\r\n  if (trimmed.includes('quiz me') || trimmed.includes('test me') || trimmed.includes('give me a quiz')) {\r\n    return 'initiate_quiz';\r\n  }\r\n  \r\n  // Detect simple, foundational questions that need direct teaching first\r\n  const isSimpleFoundational = isSimpleFoundationalQuestion(trimmed);\r\n  if (isSimpleFoundational && (!history || history.length === 0)) {\r\n    return 'direct_teaching';\r\n  }\r\n  \r\n  // Struggle indicators\r\n  const struggleIndicators = ['help', 'stuck', 'confused', 'don\\'t understand', 'don\\'t know'];\r\n  if (struggleIndicators.some(indicator => trimmed.includes(indicator))) {\r\n    return 'proactive_help';\r\n  }\r\n  \r\n  // Check if user is responding to a previous question\r\n  if (history && history.length > 0) {\r\n    const lastAIMessage = history.filter(m => m.role === 'assistant').pop();\r\n    if (lastAIMessage?.content?.includes('?')) {\r\n      // User is likely answering a question\r\n      return 'evaluate_answer';\r\n    }\r\n  }\r\n  \r\n  // Default to session initiation\r\n  return 'initiate_session';\r\n}\r\n\r\n// Detection functions for session management\r\nfunction isSessionEndingSignal(message: string): boolean {\r\n  const endingSignals = [\r\n    'i think i\\'m done',\r\n    'i\\'m done',\r\n    'that\\'s enough',\r\n    'i\\'m finished',\r\n    'i need to go',\r\n    'thanks, that\\'s all',\r\n    'goodbye',\r\n    'bye',\r\n    'see you later',\r\n    'i\\'ll stop here',\r\n    'enough for now',\r\n    'i\\'m good'\r\n  ];\r\n  \r\n  return endingSignals.some(signal => message.includes(signal));\r\n}\r\n\r\nfunction isTopicTransitionRequest(message: string): boolean {\r\n  const transitionPatterns = [\r\n    'can we go over',\r\n    'let\\'s switch to',\r\n    'let\\'s talk about',\r\n    'tell me about',\r\n    'what about',\r\n    'how about',\r\n    'let\\'s move to',\r\n    'can we discuss',\r\n    'i want to learn about',\r\n    'explain',\r\n    'teach me about'\r\n  ];\r\n  \r\n  return transitionPatterns.some(pattern => message.includes(pattern));\r\n}\r\n\r\nfunction isGratitudeExpression(message: string): boolean {\r\n  const gratitudePatterns = [\r\n    'thank you',\r\n    'thanks',\r\n    'appreciate',\r\n    'grateful',\r\n    'that helped',\r\n    'that\\'s helpful',\r\n    'nice',\r\n    'good'\r\n  ];\r\n  \r\n  // Only consider it gratitude if it's a short message focused on appreciation\r\n  if (message.length > 50) return false;\r\n  \r\n  return gratitudePatterns.some(pattern => message.includes(pattern));\r\n}\r\n\r\nfunction isSimpleFoundationalQuestion(message: string): boolean {\r\n  const simplePatterns = [\r\n    /^\\s*\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+\\s*$/,  // Basic math like \"2+2\"\r\n    /^what\\s+(is|are)\\s+\\w+(\\s+\\w+){0,3}\\??$/i,  // \"What is water?\"\r\n    /^how\\s+much\\s+(is|are)\\s+\\w+(\\s+\\w+){0,3}\\??$/i,  // \"How much is 5+5?\"\r\n    /^what\\s+color\\s+(is|are)\\s+\\w+(\\s+\\w+){0,3}\\??$/i,  // \"What color is the sky?\"\r\n    /^where\\s+(is|are)\\s+\\w+(\\s+\\w+){0,3}\\??$/i,  // \"Where is Paris?\"\r\n  ];\r\n  \r\n  return simplePatterns.some(pattern => pattern.test(message.trim()));\r\n}\r\n\r\nfunction extractOriginalTopic(clientHistory: any[], currentMessage: string): string | null {\r\n  // If this is a topic transition request, extract the new topic from current message\r\n  const trimmed = currentMessage.toLowerCase().trim();\r\n  if (isTopicTransitionRequest(trimmed)) {\r\n    // Reset and extract new topic from the transition request\r\n    return extractTopicFromMessage(currentMessage);\r\n  }\r\n  \r\n  // If this is the first user message, extract topic from it\r\n  if (clientHistory.length === 0) {\r\n    return extractTopicFromMessage(currentMessage);\r\n  }\r\n  \r\n  // Look for the first user message to determine original topic\r\n  const firstUserMessage = clientHistory.find(msg => msg.role === 'user');\r\n  if (firstUserMessage) {\r\n    return extractTopicFromMessage(firstUserMessage.content);\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\nfunction extractTopicFromMessage(message: string): string | null {\r\n  // Simple topic extraction patterns\r\n  const topicPatterns = [\r\n    /(?:learn about|tell me about|explain|what (?:is|are)|how (?:does|do))\\s+(.+?)(?:\\?|$)/i,\r\n    /^(.+?)(?:\\?|$)/i  // Fallback: take the whole message as topic\r\n  ];\r\n  \r\n  for (const pattern of topicPatterns) {\r\n    const match = message.match(pattern);\r\n    if (match && match[1]) {\r\n      return match[1].trim();\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\nfunction buildConversationSummary(clientHistory: any[]): string {\r\n  if (clientHistory.length === 0) return '';\r\n  \r\n  // Take last 4 messages to provide recent context\r\n  const recentHistory = clientHistory.slice(-4);\r\n  return recentHistory\r\n    .map(msg => `${msg.role}: ${msg.content}`)\r\n    .join('\\n');\r\n}\r\n\r\n// Helper function to provide contextual responses based on user input\r\nfunction getContextualResponse(message: string, chatMode: string, errorType: string): string {\r\n  const lowerMessage = message.toLowerCase();\r\n  \r\n  // Math questions\r\n  if (lowerMessage.match(/\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+/) || lowerMessage.includes('what') && (lowerMessage.includes('+') || lowerMessage.includes('-') || lowerMessage.includes('*') || lowerMessage.includes('/'))) {\r\n    const mathMatch = message.match(/(\\d+)\\s*([\\+\\-\\*\\/])\\s*(\\d+)/);\r\n    if (mathMatch) {\r\n      const [, num1, op, num2] = mathMatch;\r\n      const a = parseInt(num1), b = parseInt(num2);\r\n      let result;\r\n      switch(op) {\r\n        case '+': result = a + b; break;\r\n        case '-': result = a - b; break;\r\n        case '*': result = a * b; break;\r\n        case '/': result = b !== 0 ? a / b : 'undefined (cannot divide by zero)'; break;\r\n      }\r\n      \r\n      if (chatMode === 'personal') {\r\n        return `Great math question! Let me guide your thinking about ${num1} ${op} ${num2}. Instead of just giving you the answer, what do you think happens when we ${op === '+' ? 'combine' : op === '-' ? 'take away' : op === '*' ? 'repeatedly add' : 'split up'} these numbers? üßÆ`;\r\n      } else {\r\n        return `I see you're working on ${num1} ${op} ${num2}. Rather than just telling you the answer, can you think about what this operation means? What strategy could you use to solve it?`;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Cloud/weather topics\r\n  if (lowerMessage.includes('cloud') || lowerMessage.includes('weather') || lowerMessage.includes('sky')) {\r\n    if (chatMode === 'personal') {\r\n      return \"I'd love to guide your exploration of clouds! üå§Ô∏è Let's start with what fascinates you most: When you look up at the sky, what do you notice about the clouds? What questions come to mind?\";\r\n    } else {\r\n      return \"Clouds are fascinating! ‚òÅÔ∏è Rather than explaining everything at once, let's explore together. What have you observed about clouds that makes you curious?\";\r\n    }\r\n  }\r\n  \r\n  // Science topics\r\n  if (lowerMessage.includes('science') || lowerMessage.includes('physics') || lowerMessage.includes('chemistry') || lowerMessage.includes('biology')) {\r\n    if (chatMode === 'personal') {\r\n      return \"Science is everywhere around us! üî¨ What specific observation or question has sparked your curiosity? Let's explore it through questioning and discovery.\";\r\n    } else {\r\n      return \"Science offers so many fascinating areas to explore! What specific phenomenon or question interests you? I'd like to guide you to discover the answer yourself.\";\r\n    }\r\n  }\r\n  \r\n  // Generic greetings or simple questions\r\n  if (lowerMessage.includes('hello') || lowerMessage.includes('hi') || lowerMessage.includes('help')) {\r\n    if (chatMode === 'personal') {\r\n      return \"Hello! I'm your AI learning coach using the Socratic method! üéì Instead of giving direct answers, I'll guide you to discover knowledge through thoughtful questions. What topic has sparked your curiosity today?\";\r\n    } else {\r\n      return \"Hello! I'm here to help you learn through guided questioning. Rather than just providing answers, I'll help you think through problems step by step. What would you like to explore?\";\r\n    }\r\n  }\r\n  \r\n  // Error-specific responses\r\n  if (errorType === 'api_error') {\r\n    if (chatMode === 'personal') {\r\n      return `I'm having a temporary connection issue, but let's use this as a learning opportunity! ü§î About \"${message}\" - what do you already know or think about this topic? What questions does it raise for you?`;\r\n    } else {\r\n      return `I'm experiencing a technical issue, but I can still guide your learning about \"${message}\"! What aspect of this topic would you like to explore first through questioning?`;\r\n    }\r\n  }\r\n  \r\n  if (errorType === 'timeout') {\r\n    if (chatMode === 'personal') {\r\n      return `That request took longer than expected, but I haven't forgotten about \"${message}\"! üïê While I process complex questions faster, let's break this down: What specific aspect of \"${message}\" interests you most? Sometimes the best learning happens through focused questions!`;\r\n    } else {\r\n      return `The request timed out, but I can still help with \"${message}\"! Let's approach this step by step - what particular aspect would you like to explore first? I work best with focused, specific questions.`;\r\n    }\r\n  }\r\n  \r\n  // Default contextual responses using Socratic method\r\n  if (chatMode === 'personal') {\r\n    return `That's an interesting question about \"${message}\"! üß† Following the Socratic method, let me guide your thinking: What do you already know about this topic? What connections can you make to things you've learned before?`;\r\n  } else {\r\n    return `I'd be happy to guide you through exploring \"${message}\"! Rather than just telling you the answer, what do you think you already know about this? What questions does it raise for you?`;\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\knowledge-cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\mode-detection.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":108,"column":40,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":108,"endColumn":41,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4318,4319],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4318,4318],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nexport type QueryMode = 'personal' | 'general' | 'platform' | 'mixed';\r\n\r\nexport function detectQueryMode(message: string): QueryMode {\r\n  const lowerMessage = message.toLowerCase();\r\n  \r\n  // Enhanced personal data keywords - more comprehensive detection\r\n  const personalDataKeywords = [\r\n    // Flashcard-specific patterns\r\n    'my flashcards', 'my cards', 'recent flashcards', 'recent cards',\r\n    'last flashcards', 'last cards', 'newest flashcards', 'newest cards',\r\n    'recently created', 'just created', 'latest flashcards', 'latest cards',\r\n    'flashcards i created', 'cards i created', 'flashcards i made', 'cards i made',\r\n    'most recent flashcards', 'most recent cards', 'last 5 flashcards', 'last 10 flashcards',\r\n    \r\n    // Study data patterns\r\n    'my study', 'my sessions', 'my performance', 'my progress',\r\n    'my accuracy', 'my streak', 'my stats', 'my xp',\r\n    'recent study', 'last session', 'study history',\r\n    'cards i studied', 'sessions i completed',\r\n    \r\n    // Performance patterns\r\n    'how am i doing', 'my results', 'my scores',\r\n    'struggling with', 'need practice', 'review my'\r\n  ];\r\n  \r\n  // Study session keywords (highest priority for academic study)\r\n  const studySessionKeywords = [\r\n    'help me study', 'teach me about', 'can you teach me', 'i want to study',\r\n    'study with me', 'let\\'s study', 'i need to learn', 'teach me'\r\n  ];\r\n\r\n  // Platform-specific keywords for how-to guides\r\n  const platformKeywords = [\r\n    // Flashcard creation and management\r\n    'how do i make flashcards', 'how to create flashcards', 'create new flashcard',\r\n    'add flashcards', 'make flashcards', 'create cards', 'how to make cards',\r\n    'flashcard creation', 'creating flashcards', 'add new cards',\r\n    \r\n    // Platform navigation and features\r\n    'how do i use', 'how to use', 'navigate to', 'find the', 'where is',\r\n    'how to study', 'start studying', 'begin study session',\r\n    'dashboard', 'library', 'goals', 'progress tracking',\r\n    'how to track progress', 'view my stats', 'check my progress',\r\n    \r\n    // Study session guidance\r\n    'start a quiz', 'how to quiz', 'study session', 'practice mode',\r\n    'how to review', 'study my cards', 'practice flashcards',\r\n    \r\n    // Account and settings\r\n    'profile settings', 'account settings', 'change my', 'update my',\r\n    'upload files', 'import cards', 'export data',\r\n    \r\n    // General platform help\r\n    'how does this work', 'getting started', 'tutorial', 'guide me',\r\n    'show me how', 'help me', 'instructions for'\r\n  ];\r\n  \r\n  // Enhanced general knowledge patterns (external facts)\r\n  const generalKeywords = [\r\n    'what is photosynthesis', 'who was napoleon', 'what caused',\r\n    'history of', 'capital of', 'meaning of', 'examples of',\r\n    'define quantum', 'explain relativity', 'tell me about world war',\r\n    'what happened in', 'who invented', 'when was discovered',\r\n    'scientific method', 'periodic table', 'shakespeare wrote',\r\n    'mathematical concept', 'biology definition', 'chemistry equation'\r\n  ];\r\n  \r\n  // Check for personal data keywords (highest priority)\r\n  const hasPersonalKeywords = personalDataKeywords.some(keyword => \r\n    lowerMessage.includes(keyword)\r\n  );\r\n  \r\n  // Check for study session keywords (second priority)\r\n  const hasStudySessionKeywords = studySessionKeywords.some(keyword => \r\n    lowerMessage.includes(keyword)\r\n  );\r\n  \r\n  // Check for platform keywords (third priority)\r\n  const hasPlatformKeywords = platformKeywords.some(keyword => \r\n    lowerMessage.includes(keyword)\r\n  );\r\n  \r\n  // Check for general knowledge keywords (fourth priority)\r\n  const hasGeneralKeywords = generalKeywords.some(keyword => \r\n    lowerMessage.includes(keyword)\r\n  );\r\n  \r\n  // Prioritize: Personal > Study Session > Platform > General\r\n  if (hasPersonalKeywords) {\r\n    return 'personal';\r\n  }\r\n  \r\n  if (hasStudySessionKeywords) {\r\n    return 'general'; // Study sessions use general mode but with special handling\r\n  }\r\n  \r\n  if (hasPlatformKeywords) {\r\n    return 'platform';\r\n  }\r\n  \r\n  if (hasGeneralKeywords) {\r\n    return 'general';\r\n  }\r\n  \r\n  // Heuristic fallback: question-like or math-like inputs are general knowledge\r\n  const looksLikeQuestion = /\\b(what|who|why|how|when|where)\\b|\\?/i.test(lowerMessage);\r\n  const looksLikeMath = /\\b\\d+\\s*([x*√ó+\\/-])\\s*\\d+\\b/.test(lowerMessage);\r\n  if (looksLikeQuestion || looksLikeMath) {\r\n    return 'general';\r\n  }\r\n  \r\n  // Default to platform for ambiguous navigation/help-like inputs\r\n  return 'platform';\r\n}\r\n\r\n// Enhanced detection for recent flashcards specifically\r\nexport function detectRecentFlashcardsRequest(message: string): boolean {\r\n  const lowerMessage = message.toLowerCase();\r\n  \r\n  const recentFlashcardPatterns = [\r\n    'recent flashcards', 'recent cards', 'most recent flashcards', 'most recent cards',\r\n    'last flashcards', 'last cards', 'latest flashcards', 'latest cards',\r\n    'newest flashcards', 'newest cards', 'recently created',\r\n    'flashcards i created', 'cards i created', 'flashcards i made',\r\n    'last 5 flashcards', 'last 10 flashcards', 'last few flashcards',\r\n    'show me my flashcards', 'what flashcards do i have'\r\n  ];\r\n  \r\n  return recentFlashcardPatterns.some(pattern => lowerMessage.includes(pattern));\r\n}\r\n\r\n// Detection for study session requests\r\nexport function detectStudySessionRequest(message: string): boolean {\r\n  const lowerMessage = message.toLowerCase();\r\n  \r\n  const studySessionPatterns = [\r\n    'help me study', 'teach me about', 'can you teach me', 'i want to study',\r\n    'study with me', 'let\\'s study', 'i need to learn', 'teach me'\r\n  ];\r\n  \r\n  return studySessionPatterns.some(pattern => lowerMessage.includes(pattern));\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\simple-prompt-selector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\ai-study-chat\\vector-embeddings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\book-quiz-questions\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\broadcast-beta-update\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\change-subscription-tier\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\check-subscription\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\create-checkout\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\customer-portal\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\data-retention-cleanup\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\email-events\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\epub-ingestion\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\epub-proxy\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\export-organization-data\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\extract-algebra-zip\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\extract-linear-equations-zip\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\fetch-linear-equations-content\\index.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":189,"column":20,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":189,"endColumn":21,"suggestions":[{"messageId":"removeEscape","fix":{"range":[6403,6404],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[6403,6403],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\).","line":189,"column":22,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":189,"endColumn":23,"suggestions":[{"messageId":"removeEscape","fix":{"range":[6405,6406],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[6405,6405],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.50.0'\r\n\r\nconst corsHeaders = {\r\n  'Access-Control-Allow-Origin': '*',\r\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\r\n}\r\n\r\ninterface LessonContent {\r\n  id: string;\r\n  title: string;\r\n  content: string;\r\n  blocks: Array<{\r\n    type: string;\r\n    content: string;\r\n    title?: string;\r\n  }>;\r\n}\r\n\r\nDeno.serve(async (req) => {\r\n  // Handle CORS preflight requests\r\n  if (req.method === 'OPTIONS') {\r\n    return new Response(null, { headers: corsHeaders });\r\n  }\r\n\r\n  try {\r\n    // Initialize Supabase client\r\n    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;\r\n    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;\r\n    const supabase = createClient(supabaseUrl, supabaseKey);\r\n\r\n    console.log('Fetching lesson files from storage...');\r\n\r\n    // Fetch all lesson files\r\n    const lessonFiles = ['lesson_3_1.md', 'lesson_3_2.md', 'lesson_3_3.md', 'lesson_3_4.md', 'lesson_3_5.md', 'lesson_3_6.md', 'lesson_3_7.md'];\r\n    const lessons: LessonContent[] = [];\r\n\r\n    for (const filename of lessonFiles) {\r\n      console.log(`Processing ${filename}...`);\r\n      \r\n      // Download file from storage\r\n      const { data: fileData, error: downloadError } = await supabase.storage\r\n        .from('course-files')\r\n        .download(filename);\r\n\r\n      if (downloadError) {\r\n        console.error(`Error downloading ${filename}:`, downloadError);\r\n        continue;\r\n      }\r\n\r\n      // Convert file to text\r\n      const content = await fileData.text();\r\n      \r\n      // Parse lesson content\r\n      const lessonId = filename.replace('.md', '').replace('lesson_', 'lesson-');\r\n      const title = extractTitle(content);\r\n      const blocks = parseMarkdownToBlocks(content);\r\n\r\n      lessons.push({\r\n        id: lessonId,\r\n        title,\r\n        content,\r\n        blocks\r\n      });\r\n    }\r\n\r\n    // Fetch course summary\r\n    const { data: summaryData, error: summaryError } = await supabase.storage\r\n      .from('course-files')\r\n      .download('COURSE_SUMMARY.md');\r\n\r\n    let courseSummary = '';\r\n    if (!summaryError && summaryData) {\r\n      courseSummary = await summaryData.text();\r\n    }\r\n\r\n    console.log(`Successfully processed ${lessons.length} lessons`);\r\n\r\n    return new Response(\r\n      JSON.stringify({\r\n        success: true,\r\n        lessons: lessons.sort((a, b) => a.id.localeCompare(b.id)),\r\n        courseSummary: extractCourseSummary(courseSummary)\r\n      }),\r\n      { \r\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n        status: 200 \r\n      }\r\n    );\r\n\r\n  } catch (error) {\r\n    console.error('Error processing lessons:', error);\r\n    return new Response(\r\n      JSON.stringify({ \r\n        success: false, \r\n        error: error.message \r\n      }),\r\n      { \r\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n        status: 500 \r\n      }\r\n    );\r\n  }\r\n});\r\n\r\nfunction extractTitle(content: string): string {\r\n  const lines = content.split('\\n');\r\n  const titleLine = lines.find(line => line.startsWith('# '));\r\n  return titleLine ? titleLine.replace('# ', '').trim() : 'Untitled Lesson';\r\n}\r\n\r\nfunction extractCourseSummary(content: string): string {\r\n  if (!content) return 'Master solving linear equations through interactive lessons and practice problems';\r\n  \r\n  const lines = content.split('\\n');\r\n  const summaryStart = lines.findIndex(line => line.toLowerCase().includes('summary') || line.toLowerCase().includes('description'));\r\n  \r\n  if (summaryStart > -1) {\r\n    const summaryLines = lines.slice(summaryStart + 1, summaryStart + 5);\r\n    return summaryLines.join(' ').trim() || 'Master solving linear equations through interactive lessons and practice problems';\r\n  }\r\n  \r\n  return 'Master solving linear equations through interactive lessons and practice problems';\r\n}\r\n\r\nfunction parseMarkdownToBlocks(content: string): Array<{type: string, content: string, title?: string}> {\r\n  const lines = content.split('\\n');\r\n  const blocks: Array<{type: string, content: string, title?: string}> = [];\r\n  let currentBlock: {type: string, content: string[], title?: string} | null = null;\r\n\r\n  console.log(`Parsing content with ${lines.length} lines`);\r\n\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const line = lines[i].trim();\r\n    \r\n    // Skip empty lines at start of processing\r\n    if (!line && !currentBlock) continue;\r\n    \r\n    // Headers (## or ###)\r\n    if (line.startsWith('## ') || line.startsWith('### ')) {\r\n      // Finalize previous block\r\n      if (currentBlock && currentBlock.content.length > 0) {\r\n        blocks.push(finalizeBlock(currentBlock));\r\n      }\r\n      \r\n      // Start new text block\r\n      currentBlock = {\r\n        type: 'text',\r\n        title: line.replace(/^#+\\s*/, ''),\r\n        content: []\r\n      };\r\n      console.log(`Created text block: ${currentBlock.title}`);\r\n    }\r\n    // Main heading (single #)\r\n    else if (line.startsWith('# ')) {\r\n      // Skip main title, already extracted\r\n      continue;\r\n    }\r\n    // Interactive elements (look for keywords)\r\n    else if (line.toLowerCase().includes('interactive') || line.toLowerCase().includes('practice') || line.toLowerCase().includes('exercise')) {\r\n      if (currentBlock && currentBlock.content.length > 0) {\r\n        blocks.push(finalizeBlock(currentBlock));\r\n      }\r\n      currentBlock = {\r\n        type: 'practice',\r\n        title: 'Interactive Practice',\r\n        content: [line]\r\n      };\r\n      console.log(`Created practice block: Interactive Practice`);\r\n    }\r\n    // Math expressions or equations\r\n    else if (line.includes('=') && (line.includes('x') || line.includes('y') || line.includes('a') || line.includes('b') || /\\d+/.test(line))) {\r\n      if (currentBlock && currentBlock.type === 'example') {\r\n        // Continue building example block\r\n        currentBlock.content.push(line);\r\n      } else {\r\n        // Start new example block\r\n        if (currentBlock && currentBlock.content.length > 0) {\r\n          blocks.push(finalizeBlock(currentBlock));\r\n        }\r\n        currentBlock = {\r\n          type: 'example',\r\n          title: 'Mathematical Example',\r\n          content: [line]\r\n        };\r\n        console.log(`Created example block: Mathematical Example`);\r\n      }\r\n    }\r\n    // Problems or exercises (lines starting with numbers or \"Problem:\")\r\n    else if (/^\\d+[\\.\\)]/.test(line) || line.toLowerCase().startsWith('problem') || line.toLowerCase().startsWith('solve')) {\r\n      if (currentBlock && currentBlock.type === 'practice') {\r\n        // Continue building practice block\r\n        currentBlock.content.push(line);\r\n      } else {\r\n        // Start new practice block\r\n        if (currentBlock && currentBlock.content.length > 0) {\r\n          blocks.push(finalizeBlock(currentBlock));\r\n        }\r\n        currentBlock = {\r\n          type: 'practice',\r\n          title: 'Practice Problems',\r\n          content: [line]\r\n        };\r\n        console.log(`Created practice block: Practice Problems`);\r\n      }\r\n    }\r\n    // Step-by-step solutions (look for \"Step\" keywords)\r\n    else if (line.toLowerCase().includes('step') && (line.includes('1') || line.includes('2') || line.includes(':'))) {\r\n      if (currentBlock && currentBlock.type === 'example') {\r\n        currentBlock.content.push(line);\r\n      } else {\r\n        if (currentBlock && currentBlock.content.length > 0) {\r\n          blocks.push(finalizeBlock(currentBlock));\r\n        }\r\n        currentBlock = {\r\n          type: 'example',\r\n          title: 'Step-by-Step Solution',\r\n          content: [line]\r\n        };\r\n        console.log(`Created example block: Step-by-Step Solution`);\r\n      }\r\n    }\r\n    // Quiz indicators\r\n    else if (line.toLowerCase().includes('quiz') || line.toLowerCase().includes('test') || line.toLowerCase().includes('check your understanding')) {\r\n      if (currentBlock && currentBlock.content.length > 0) {\r\n        blocks.push(finalizeBlock(currentBlock));\r\n      }\r\n      currentBlock = {\r\n        type: 'quiz',\r\n        title: 'Knowledge Check',\r\n        content: [line]\r\n      };\r\n      console.log(`Created quiz block: Knowledge Check`);\r\n    }\r\n    // Regular content\r\n    else if (line) {\r\n      if (!currentBlock) {\r\n        currentBlock = {\r\n          type: 'text',\r\n          title: 'Lesson Content',\r\n          content: [line]\r\n        };\r\n      } else {\r\n        currentBlock.content.push(line);\r\n      }\r\n    }\r\n    // Empty line - continue building current block\r\n    else if (currentBlock) {\r\n      currentBlock.content.push('');\r\n    }\r\n  }\r\n  \r\n  // Finalize the last block\r\n  if (currentBlock && currentBlock.content.length > 0) {\r\n    blocks.push(finalizeBlock(currentBlock));\r\n  }\r\n  \r\n  console.log(`Generated ${blocks.length} content blocks`);\r\n  return blocks;\r\n}\r\n\r\nfunction finalizeBlock(block: {type: string, content: string[], title?: string}): {type: string, content: string, title?: string} {\r\n  const content = block.content.join('\\n').trim();\r\n  \r\n  const finalizedBlock = {\r\n    type: block.type,\r\n    content: content,\r\n    title: block.title\r\n  };\r\n  \r\n  console.log(`Finalized ${block.type} block: \"${block.title}\" (${content.length} chars)`);\r\n  return finalizedBlock;\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\generate-homepage-background\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\generate-study-insights\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\get-flashcards-by-group\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\get-recent-flashcards\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\get-study-stats\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\get-user-flashcards\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\google-calendar-sync\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\gutenberg-ingestion\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\native-content-proxy\\index.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":49,"column":65,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":49,"endColumn":66,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1519,1520],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1519,1519],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.50.0';\r\n\r\nconst corsHeaders = {\r\n  'Access-Control-Allow-Origin': '*',\r\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\r\n};\r\n\r\n// MIME type mapping for different file extensions\r\nconst getMimeType = (path: string): string => {\r\n  const ext = path.toLowerCase().split('.').pop() || '';\r\n  const mimeTypes: { [key: string]: string } = {\r\n    'html': 'text/html',\r\n    'css': 'text/css',\r\n    'js': 'application/javascript',\r\n    'json': 'application/json',\r\n    'png': 'image/png',\r\n    'jpg': 'image/jpeg',\r\n    'jpeg': 'image/jpeg',\r\n    'gif': 'image/gif',\r\n    'svg': 'image/svg+xml',\r\n    'woff': 'font/woff',\r\n    'woff2': 'font/woff2',\r\n    'ttf': 'font/ttf',\r\n    'mp4': 'video/mp4',\r\n    'webm': 'video/webm',\r\n    'mp3': 'audio/mpeg',\r\n    'wav': 'audio/wav',\r\n    'pdf': 'application/pdf',\r\n  };\r\n  return mimeTypes[ext] || 'application/octet-stream';\r\n};\r\n\r\nDeno.serve(async (req) => {\r\n  // Handle CORS preflight requests\r\n  if (req.method === 'OPTIONS') {\r\n    return new Response(null, { headers: corsHeaders });\r\n  }\r\n\r\n  // Health check endpoint\r\n  const url = new URL(req.url);\r\n  if (url.pathname === '/health') {\r\n    return new Response(JSON.stringify({ status: 'healthy' }), {\r\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n    });\r\n  }\r\n\r\n  try {\r\n    // Parse the URL path: /native-content/:pkg/*\r\n    const pathMatch = url.pathname.match(/^\\/native-content\\/([^\\/]+)\\/(.*)$/);\r\n    if (!pathMatch) {\r\n      return new Response('Invalid path format. Expected: /native-content/:pkg/path', {\r\n        status: 400,\r\n        headers: corsHeaders,\r\n      });\r\n    }\r\n\r\n    const [, packageName, filePath] = pathMatch;\r\n    console.log(`üìÇ Native content request: pkg=${packageName}, file=${filePath}`);\r\n\r\n    // Initialize Supabase client\r\n    const supabaseUrl = Deno.env.get('SUPABASE_URL');\r\n    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');\r\n\r\n    if (!supabaseUrl || !supabaseKey) {\r\n      throw new Error('Missing Supabase configuration');\r\n    }\r\n\r\n    const supabase = createClient(supabaseUrl, supabaseKey);\r\n\r\n    // Build the storage path for the requested file\r\n    const storagePath = `lessons/${packageName}/${filePath}`;\r\n    \r\n    console.log(`üîç Looking for file at: scorm-public/${storagePath}`);\r\n\r\n    // Download the file from Supabase storage\r\n    const { data: fileData, error } = await supabase.storage\r\n      .from('scorm-public')\r\n      .download(storagePath);\r\n\r\n    if (error || !fileData) {\r\n      console.log(`‚ùå File not found: ${storagePath}`, error);\r\n      return new Response('File not found', {\r\n        status: 404,\r\n        headers: corsHeaders,\r\n      });\r\n    }\r\n\r\n    console.log(`‚úÖ File found, size: ${fileData.size} bytes`);\r\n\r\n    // Convert blob to array buffer for response\r\n    const arrayBuffer = await fileData.arrayBuffer();\r\n    const contentType = getMimeType(filePath);\r\n\r\n    // Return the file with appropriate headers\r\n    return new Response(arrayBuffer, {\r\n      headers: {\r\n        ...corsHeaders,\r\n        'Content-Type': contentType,\r\n        'Cache-Control': 'public, max-age=3600', // Cache for 1 hour\r\n        'Content-Length': fileData.size.toString(),\r\n      },\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå Native content proxy error:', error);\r\n    \r\n    return new Response(\r\n      JSON.stringify({ \r\n        error: 'Internal server error', \r\n        message: error instanceof Error ? error.message : 'Unknown error' \r\n      }),\r\n      {\r\n        status: 500,\r\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n      }\r\n    );\r\n  }\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\notification-system\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\opds-ingestion\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\process-file-flashcards\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\process-kb-file\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\process-scorm-package\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\process-user-content\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\quizlet-proxy\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\redeem-coupon\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\retrieve-knowledge\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\save-preview-flashcards\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-analytics-export\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-analytics\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-content-proxy\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-content-server\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-extract-package\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-generate-content\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-native-converter\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-parser-advanced\\index.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":48,"column":120,"nodeType":"TemplateElement","messageId":"unnecessaryEscape","endLine":48,"endColumn":121,"suggestions":[{"messageId":"removeEscape","fix":{"range":[2174,2175],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[2174,2174],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import \"https://deno.land/x/xhr@0.1.0/mod.ts\";\r\nimport { serve } from \"https://deno.land/std@0.168.0/http/server.ts\";\r\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2.50.0';\r\n\r\nconst corsHeaders = {\r\n  'Access-Control-Allow-Origin': '*',\r\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\r\n};\r\n\r\n// Simplified XML parser for edge function environment\r\nfunction parseManifestXML(xmlContent: string) {\r\n  try {\r\n    // Detect SCORM standard\r\n    const isScorm2004 = xmlContent.includes('imsss:') || \r\n                        xmlContent.includes('2004') || \r\n                        xmlContent.includes('adlcp:scormType');\r\n    \r\n    // Extract basic manifest info using regex (simplified for edge function)\r\n    const manifestMatch = xmlContent.match(/<manifest[^>]*identifier=\"([^\"]*)\"[^>]*>/);\r\n    const identifier = manifestMatch?.[1] || 'unknown';\r\n    \r\n    const titleMatch = xmlContent.match(/<title[^>]*>([^<]*)<\\/title>/);\r\n    const title = titleMatch?.[1] || 'Untitled Package';\r\n    \r\n    // Extract organizations\r\n    const organizationsMatch = xmlContent.match(/<organizations[^>]*default=\"([^\"]*)\"[^>]*>/);\r\n    const defaultOrg = organizationsMatch?.[1] || '';\r\n    \r\n    // Extract SCOs by finding items with identifierref and matching resources\r\n    const itemMatches = Array.from(xmlContent.matchAll(/<item[^>]*identifier=\"([^\"]*)\"[^>]*identifierref=\"([^\"]*)\"[^>]*>/g));\r\n    const resourceMatches = Array.from(xmlContent.matchAll(/<resource[^>]*identifier=\"([^\"]*)\"[^>]*href=\"([^\"]*)\"[^>]*(?:adlcp:scormType=\"([^\"]*)\")?[^>]*>/g));\r\n    \r\n    const resources = new Map();\r\n    resourceMatches.forEach(match => {\r\n      resources.set(match[1], {\r\n        identifier: match[1],\r\n        href: match[2],\r\n        scormType: match[3] || 'sco'\r\n      });\r\n    });\r\n    \r\n    const scos = itemMatches.map((match, index) => {\r\n      const itemId = match[1];\r\n      const resourceRef = match[2];\r\n      const resource = resources.get(resourceRef);\r\n      \r\n      // Extract item title\r\n      const itemTitleMatch = xmlContent.match(new RegExp(`<item[^>]*identifier=\"${itemId}\"[^>]*>.*?<title[^>]*>([^<]*)<\\/title>`, 's'));\r\n      const itemTitle = itemTitleMatch?.[1] || `SCO ${index + 1}`;\r\n      \r\n      return {\r\n        identifier: itemId,\r\n        title: itemTitle,\r\n        launch_href: resource?.href || '',\r\n        parameters: '',\r\n        mastery_score: 80, // Default mastery score\r\n        prerequisites: [],\r\n        seq_order: index + 1,\r\n        is_launchable: resource?.scormType === 'sco'\r\n      };\r\n    });\r\n    \r\n    return {\r\n      standard: isScorm2004 ? 'SCORM 2004' : 'SCORM 1.2',\r\n      identifier,\r\n      title,\r\n      organizations: [{\r\n        identifier: defaultOrg || 'default_org',\r\n        title: title,\r\n        items: scos\r\n      }],\r\n      scos,\r\n      validation: {\r\n        isValid: scos.length > 0,\r\n        errors: scos.length === 0 ? ['No launchable SCOs found'] : [],\r\n        warnings: []\r\n      }\r\n    };\r\n  } catch (error) {\r\n    throw new Error(`Failed to parse manifest: ${error.message}`);\r\n  }\r\n}\r\n\r\nserve(async (req) => {\r\n  // Handle CORS preflight requests\r\n  if (req.method === 'OPTIONS') {\r\n    return new Response(null, { headers: corsHeaders });\r\n  }\r\n\r\n  try {\r\n    const supabaseClient = createClient(\r\n      Deno.env.get('SUPABASE_URL') ?? '',\r\n      Deno.env.get('SUPABASE_ANON_KEY') ?? '',\r\n      {\r\n        global: {\r\n          headers: { Authorization: req.headers.get('Authorization')! },\r\n        },\r\n      }\r\n    );\r\n\r\n    const { packageId, zipPath } = await req.json();\r\n    \r\n    if (!packageId || !zipPath) {\r\n      return new Response(\r\n        JSON.stringify({ error: 'Missing required fields: packageId, zipPath' }),\r\n        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n\r\n    console.log('Parsing SCORM package:', packageId);\r\n\r\n    // Download the ZIP file from storage\r\n    const { data: zipData, error: downloadError } = await supabaseClient.storage\r\n      .from('scorm-packages')\r\n      .download(zipPath);\r\n\r\n    if (downloadError) {\r\n      throw new Error(`Failed to download package: ${downloadError.message}`);\r\n    }\r\n\r\n    // For now, simulate the extraction and parsing\r\n    // In a full implementation, you would extract the ZIP and read imsmanifest.xml\r\n    const simulatedManifestXML = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<manifest identifier=\"SCORM_PACKAGE_${packageId}\" version=\"1.2\">\r\n  <organizations default=\"default_org\">\r\n    <organization identifier=\"default_org\">\r\n      <title>Sample SCORM Package</title>\r\n      <item identifier=\"sco1\" identifierref=\"res1\">\r\n        <title>Introduction</title>\r\n      </item>\r\n    </organization>\r\n  </organizations>\r\n  <resources>\r\n    <resource identifier=\"res1\" type=\"webcontent\" adlcp:scormType=\"sco\" href=\"index.html\">\r\n      <file href=\"index.html\"/>\r\n    </resource>\r\n  </resources>\r\n</manifest>`;\r\n\r\n    const parsedManifest = parseManifestXML(simulatedManifestXML);\r\n    const extractPath = `scorm-unpacked/${packageId}`;\r\n\r\n    // Update the package status and metadata\r\n    const { error: packageError } = await supabaseClient\r\n      .from('scorm_packages')\r\n      .update({\r\n        status: 'ready',\r\n        extract_path: extractPath,\r\n        metadata: {\r\n          manifest: parsedManifest,\r\n          parsed_at: new Date().toISOString(),\r\n          standard: parsedManifest.standard\r\n        }\r\n      })\r\n      .eq('id', packageId);\r\n\r\n    if (packageError) {\r\n      throw packageError;\r\n    }\r\n\r\n    // Insert SCO records\r\n    const scoInserts = parsedManifest.scos.map(sco => ({\r\n      package_id: packageId,\r\n      identifier: sco.identifier,\r\n      title: sco.title,\r\n      launch_href: sco.launch_href,\r\n      parameters: sco.parameters || null,\r\n      mastery_score: sco.mastery_score,\r\n      seq_order: sco.seq_order,\r\n      prerequisites: sco.prerequisites || [],\r\n      is_launchable: sco.is_launchable\r\n    }));\r\n\r\n    const { error: scosError } = await supabaseClient\r\n      .from('scorm_scos')\r\n      .insert(scoInserts);\r\n\r\n    if (scosError) {\r\n      throw scosError;\r\n    }\r\n\r\n    console.log('SCORM package parsed successfully:', packageId);\r\n\r\n    return new Response(\r\n      JSON.stringify({\r\n        success: true,\r\n        packageId,\r\n        manifest: parsedManifest,\r\n        extractPath,\r\n        scosCreated: scoInserts.length,\r\n        standard: parsedManifest.standard,\r\n        validation: parsedManifest.validation\r\n      }),\r\n      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\r\n    );\r\n\r\n  } catch (error) {\r\n    console.error('Error in scorm-parser-advanced function:', error);\r\n    return new Response(\r\n      JSON.stringify({ \r\n        error: error.message,\r\n        details: 'Failed to parse SCORM package'\r\n      }),\r\n      { \r\n        status: 500, \r\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' } \r\n      }\r\n    );\r\n  }\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-parser-production\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-parser\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-runtime-advanced\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-runtime-api\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-runtime-production\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\scorm-verify-package\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\search-flashcards\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\send-invitation-email\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\send-organization-notification\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\simple-ai-chat\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\speech-to-text\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\test-function\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\text-to-voice\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\upload-course-images\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\upload-vector-images\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\usage-tracking\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\voice-to-text\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\xp-backfill\\index.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":420,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":423,"endColumn":33,"suggestions":[{"messageId":"addBrackets","fix":{"range":[13832,14157],"text":"{ const { data: completions } = await supabaseClient\r\n          .from('enrollments')\r\n          .select('progress')\r\n          .eq('user_id', userId)\r\n        \r\n        const moduleCount = completions?.filter((e: any) => e.progress?.completed === true).length || 0\r\n        earned = moduleCount >= criteria.count\r\n        break }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":425,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":425,"endColumn":104,"suggestions":[{"messageId":"addBrackets","fix":{"range":[13832,14157],"text":"{ const { data: completions } = await supabaseClient\r\n          .from('enrollments')\r\n          .select('progress')\r\n          .eq('user_id', userId)\r\n        \r\n        const moduleCount = completions?.filter((e: any) => e.progress?.completed === true).length || 0\r\n        earned = moduleCount >= criteria.count\r\n        break }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":430,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":431,"endColumn":85,"suggestions":[{"messageId":"addBrackets","fix":{"range":[14197,14391],"text":"{ const totalHours = activities.reading_sessions\r\n          .reduce((sum, session) => sum + (session.duration_seconds || 0), 0) / 3600\r\n        earned = totalHours >= criteria.hours\r\n        break }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { serve } from \"https://deno.land/std@0.168.0/http/server.ts\"\r\nimport { createClient } from \"https://esm.sh/@supabase/supabase-js@2\"\r\n\r\nconst corsHeaders = {\r\n  'Access-Control-Allow-Origin': '*',\r\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\r\n}\r\n\r\ninterface BackfillResult {\r\n  user_id: string;\r\n  before_xp: number;\r\n  after_xp: number;\r\n  before_level: number;\r\n  after_level: number;\r\n  events_created: number;\r\n  badges_awarded: string[];\r\n  activities_processed: {\r\n    flashcards: number;\r\n    study_sessions: number;\r\n    notes: number;\r\n    goals: number;\r\n    reading_sessions: number;\r\n    file_uploads: number;\r\n  };\r\n}\r\n\r\ninterface ActivitySummary {\r\n  flashcards: any[];\r\n  study_sessions: any[];\r\n  notes: any[];\r\n  goals: any[];\r\n  reading_sessions: any[];\r\n  file_uploads: any[];\r\n}\r\n\r\nserve(async (req) => {\r\n  if (req.method === 'OPTIONS') {\r\n    return new Response(null, { headers: corsHeaders });\r\n  }\r\n\r\n  try {\r\n    const supabaseClient = createClient(\r\n      Deno.env.get('SUPABASE_URL') ?? '',\r\n      Deno.env.get('SUPABASE_ANON_KEY') ?? '',\r\n      {\r\n        global: {\r\n          headers: { Authorization: req.headers.get('Authorization')! },\r\n        },\r\n      }\r\n    )\r\n\r\n    const { data: { user } } = await supabaseClient.auth.getUser()\r\n    if (!user) {\r\n      return new Response('Unauthorized', { status: 401, headers: corsHeaders })\r\n    }\r\n\r\n    const { action, dry_run = false, user_id = null } = await req.json()\r\n\r\n    switch (action) {\r\n      case 'backfill_xp':\r\n        return await backfillUserXP(supabaseClient, user_id || user.id, dry_run)\r\n      case 'backfill_all_users':\r\n        return await backfillAllUsers(supabaseClient, dry_run)\r\n      case 'rollback_backfill':\r\n        return await rollbackBackfill(supabaseClient, user_id || user.id)\r\n      case 'get_backfill_report':\r\n        return await getBackfillReport(supabaseClient, user_id || user.id)\r\n      default:\r\n        return new Response('Invalid action', { status: 400, headers: corsHeaders })\r\n    }\r\n  } catch (error) {\r\n    console.error('XP Backfill Error:', error)\r\n    return new Response(JSON.stringify({ error: error.message }), {\r\n      status: 500,\r\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n    })\r\n  }\r\n})\r\n\r\nasync function backfillUserXP(supabaseClient: any, userId: string, dryRun: boolean = false): Promise<Response> {\r\n  console.log(`Starting XP backfill for user ${userId}, dry_run: ${dryRun}`)\r\n\r\n  // Get user's current XP state\r\n  const { data: currentXP } = await supabaseClient\r\n    .from('user_xp')\r\n    .select('*')\r\n    .eq('user_id', userId)\r\n    .single()\r\n\r\n  const beforeXP = currentXP?.total_xp || 0\r\n  const beforeLevel = currentXP?.level || 1\r\n\r\n  // Collect all historical activities\r\n  const activities = await collectUserActivities(supabaseClient, userId)\r\n  console.log(`Collected activities for user ${userId}:`, {\r\n    flashcards: activities.flashcards.length,\r\n    study_sessions: activities.study_sessions.length,\r\n    notes: activities.notes.length,\r\n    goals: activities.goals.length,\r\n    reading_sessions: activities.reading_sessions.length,\r\n    file_uploads: activities.file_uploads.length\r\n  })\r\n\r\n  // Generate XP events (idempotent)\r\n  const xpEvents = await generateXPEvents(supabaseClient, userId, activities, dryRun)\r\n  console.log(`Generated ${xpEvents.length} XP events for user ${userId}`)\r\n\r\n  if (dryRun) {\r\n    // Calculate what the totals would be\r\n    const totalBackfillXP = xpEvents.reduce((sum, event) => sum + event.event_value, 0)\r\n    const projectedTotalXP = beforeXP + totalBackfillXP\r\n    \r\n    const { data: levelData } = await supabaseClient.rpc('calculate_level_from_xp', {\r\n      total_xp: projectedTotalXP\r\n    })\r\n    const projectedLevel = levelData?.[0]?.level || 1\r\n\r\n    return new Response(JSON.stringify({\r\n      dry_run: true,\r\n      user_id: userId,\r\n      before_xp: beforeXP,\r\n      projected_after_xp: projectedTotalXP,\r\n      before_level: beforeLevel,\r\n      projected_after_level: projectedLevel,\r\n      events_to_create: xpEvents.length,\r\n      backfill_xp: totalBackfillXP,\r\n      activities_found: {\r\n        flashcards: activities.flashcards.length,\r\n        study_sessions: activities.study_sessions.length,\r\n        notes: activities.notes.length,\r\n        goals: activities.goals.length,\r\n        reading_sessions: activities.reading_sessions.length,\r\n        file_uploads: activities.file_uploads.length\r\n      }\r\n    }), {\r\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n    })\r\n  }\r\n\r\n  // Insert XP events\r\n  if (xpEvents.length > 0) {\r\n    const { error: insertError } = await supabaseClient\r\n      .from('xp_events')\r\n      .insert(xpEvents)\r\n\r\n    if (insertError) {\r\n      console.error('Error inserting XP events:', insertError)\r\n      throw insertError\r\n    }\r\n  }\r\n\r\n  // Recalculate user totals\r\n  const { data: totalXPResult } = await supabaseClient\r\n    .from('xp_events')\r\n    .select('event_value')\r\n    .eq('user_id', userId)\r\n\r\n  const newTotalXP = totalXPResult?.reduce((sum: number, event: any) => sum + event.event_value, 0) || 0\r\n\r\n  // Calculate new level\r\n  const { data: levelData } = await supabaseClient.rpc('calculate_level_from_xp', {\r\n    total_xp: newTotalXP\r\n  })\r\n\r\n  const newLevel = levelData?.[0]?.level || 1\r\n  const nextLevelXP = levelData?.[0]?.next_level_xp || 100\r\n\r\n  // Update user XP record\r\n  await supabaseClient\r\n    .from('user_xp')\r\n    .upsert({\r\n      user_id: userId,\r\n      total_xp: newTotalXP,\r\n      level: newLevel,\r\n      next_level_xp: nextLevelXP\r\n    })\r\n\r\n  // Update profile for compatibility\r\n  await supabaseClient\r\n    .from('profiles')\r\n    .update({ total_xp: newTotalXP })\r\n    .eq('id', userId)\r\n\r\n  // Check and award retroactive badges\r\n  const newBadges = await checkAndAwardRetroactiveBadges(supabaseClient, userId, activities)\r\n\r\n  const result: BackfillResult = {\r\n    user_id: userId,\r\n    before_xp: beforeXP,\r\n    after_xp: newTotalXP,\r\n    before_level: beforeLevel,\r\n    after_level: newLevel,\r\n    events_created: xpEvents.length,\r\n    badges_awarded: newBadges.map(b => b.name),\r\n    activities_processed: {\r\n      flashcards: activities.flashcards.length,\r\n      study_sessions: activities.study_sessions.length,\r\n      notes: activities.notes.length,\r\n      goals: activities.goals.length,\r\n      reading_sessions: activities.reading_sessions.length,\r\n      file_uploads: activities.file_uploads.length\r\n    }\r\n  }\r\n\r\n  console.log('Backfill completed for user:', result)\r\n\r\n  return new Response(JSON.stringify(result), {\r\n    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n  })\r\n}\r\n\r\nasync function collectUserActivities(supabaseClient: any, userId: string): Promise<ActivitySummary> {\r\n  const [\r\n    flashcardsResponse,\r\n    studySessionsResponse,\r\n    notesResponse,\r\n    goalsResponse,\r\n    readingSessionsResponse,\r\n    fileUploadsResponse\r\n  ] = await Promise.all([\r\n    supabaseClient.from('flashcards').select('*').eq('user_id', userId),\r\n    supabaseClient.from('study_sessions').select('*').eq('user_id', userId).not('completed_at', 'is', null),\r\n    supabaseClient.from('notes').select('*').eq('user_id', userId),\r\n    supabaseClient.from('goals').select('*').eq('user_id', userId).eq('status', 'completed'),\r\n    supabaseClient.from('reading_sessions').select('*').eq('user_id', userId),\r\n    supabaseClient.from('file_uploads').select('*').eq('user_id', userId).eq('processing_status', 'completed')\r\n  ])\r\n\r\n  return {\r\n    flashcards: flashcardsResponse.data || [],\r\n    study_sessions: studySessionsResponse.data || [],\r\n    notes: notesResponse.data || [],\r\n    goals: goalsResponse.data || [],\r\n    reading_sessions: readingSessionsResponse.data || [],\r\n    file_uploads: fileUploadsResponse.data || []\r\n  }\r\n}\r\n\r\nasync function generateXPEvents(supabaseClient: any, userId: string, activities: ActivitySummary, dryRun: boolean): Promise<any[]> {\r\n  const events: any[] = []\r\n\r\n  // Check existing events to avoid duplicates\r\n  const { data: existingEvents } = await supabaseClient\r\n    .from('xp_events')\r\n    .select('metadata')\r\n    .eq('user_id', userId)\r\n\r\n  const existingSourceIds = new Set(\r\n    existingEvents?.map((e: any) => e.metadata?.source_id).filter(Boolean) || []\r\n  )\r\n\r\n  // Flashcard creation XP (5 XP each)\r\n  for (const flashcard of activities.flashcards) {\r\n    if (!existingSourceIds.has(`flashcard_${flashcard.id}`)) {\r\n      events.push({\r\n        user_id: userId,\r\n        event_type: 'flashcard_created',\r\n        event_value: 5,\r\n        metadata: {\r\n          source_id: `flashcard_${flashcard.id}`,\r\n          flashcard_id: flashcard.id,\r\n          description: 'Retroactive XP for flashcard creation',\r\n          backfill: true\r\n        },\r\n        created_at: flashcard.created_at\r\n      })\r\n    }\r\n  }\r\n\r\n  // Study session XP (variable based on performance)\r\n  for (const session of activities.study_sessions) {\r\n    if (!existingSourceIds.has(`study_session_${session.id}`)) {\r\n      const baseXP = Math.floor((session.correct_answers || 0) / 10) * 5\r\n      const accuracyBonus = (session.correct_answers === session.total_cards) ? 10 : 0\r\n      const speedBonus = (session.session_duration_seconds < 300) ? 5 : 0\r\n      const totalXP = baseXP + accuracyBonus + speedBonus\r\n\r\n      events.push({\r\n        user_id: userId,\r\n        event_type: 'flashcard_study',\r\n        event_value: Math.max(totalXP, 5), // Minimum 5 XP per session\r\n        metadata: {\r\n          source_id: `study_session_${session.id}`,\r\n          session_id: session.id,\r\n          correct_answers: session.correct_answers,\r\n          total_cards: session.total_cards,\r\n          duration_seconds: session.session_duration_seconds,\r\n          description: 'Retroactive XP for study session',\r\n          backfill: true\r\n        },\r\n        created_at: session.completed_at || session.created_at\r\n      })\r\n    }\r\n  }\r\n\r\n  // Note creation XP (10 XP each)\r\n  for (const note of activities.notes) {\r\n    if (!existingSourceIds.has(`note_${note.id}`)) {\r\n      events.push({\r\n        user_id: userId,\r\n        event_type: 'note_created',\r\n        event_value: 10,\r\n        metadata: {\r\n          source_id: `note_${note.id}`,\r\n          note_id: note.id,\r\n          description: 'Retroactive XP for note creation',\r\n          backfill: true\r\n        },\r\n        created_at: note.created_at\r\n      })\r\n    }\r\n  }\r\n\r\n  // Goal completion XP (30-50 XP based on priority)\r\n  for (const goal of activities.goals) {\r\n    if (!existingSourceIds.has(`goal_${goal.id}`)) {\r\n      let xpValue = 30\r\n      switch (goal.priority) {\r\n        case 'high': xpValue = 50; break\r\n        case 'medium': xpValue = 40; break\r\n        case 'low': xpValue = 30; break\r\n      }\r\n\r\n      events.push({\r\n        user_id: userId,\r\n        event_type: 'goal_completed',\r\n        event_value: xpValue,\r\n        metadata: {\r\n          source_id: `goal_${goal.id}`,\r\n          goal_id: goal.id,\r\n          priority: goal.priority,\r\n          description: 'Retroactive XP for goal completion',\r\n          backfill: true\r\n        },\r\n        created_at: goal.completed_at || goal.updated_at\r\n      })\r\n    }\r\n  }\r\n\r\n  // Reading session XP (time + page based)\r\n  for (const session of activities.reading_sessions) {\r\n    if (!existingSourceIds.has(`reading_session_${session.id}`)) {\r\n      const timeXP = Math.floor((session.duration_seconds || 0) / 600) * 5 // 5 XP per 10 minutes\r\n      const pageXP = (session.pages_read || 0) * 2 // 2 XP per page\r\n      const totalXP = Math.max(timeXP + pageXP, 5) // Minimum 5 XP\r\n\r\n      events.push({\r\n        user_id: userId,\r\n        event_type: 'reading_session',\r\n        event_value: totalXP,\r\n        metadata: {\r\n          source_id: `reading_session_${session.id}`,\r\n          session_id: session.id,\r\n          duration_seconds: session.duration_seconds,\r\n          pages_read: session.pages_read,\r\n          description: 'Retroactive XP for reading session',\r\n          backfill: true\r\n        },\r\n        created_at: session.session_end || session.created_at\r\n      })\r\n    }\r\n  }\r\n\r\n  // File upload XP (15 XP each)\r\n  for (const upload of activities.file_uploads) {\r\n    if (!existingSourceIds.has(`file_upload_${upload.id}`)) {\r\n      events.push({\r\n        user_id: userId,\r\n        event_type: 'file_uploaded',\r\n        event_value: 15,\r\n        metadata: {\r\n          source_id: `file_upload_${upload.id}`,\r\n          upload_id: upload.id,\r\n          file_name: upload.file_name,\r\n          description: 'Retroactive XP for file upload',\r\n          backfill: true\r\n        },\r\n        created_at: upload.updated_at\r\n      })\r\n    }\r\n  }\r\n\r\n  return events\r\n}\r\n\r\nasync function checkAndAwardRetroactiveBadges(supabaseClient: any, userId: string, activities: ActivitySummary): Promise<any[]> {\r\n  // Get all available badges\r\n  const { data: allBadges } = await supabaseClient\r\n    .from('badges')\r\n    .select('*')\r\n\r\n  // Get user's current badges\r\n  const { data: userBadges } = await supabaseClient\r\n    .from('user_badges')\r\n    .select('badge_id')\r\n    .eq('user_id', userId)\r\n\r\n  const earnedBadgeIds = new Set(userBadges?.map(ub => ub.badge_id) || [])\r\n  const newBadges = []\r\n\r\n  for (const badge of allBadges || []) {\r\n    if (earnedBadgeIds.has(badge.id)) continue\r\n\r\n    const criteria = badge.criteria as any\r\n    let earned = false\r\n\r\n    switch (criteria.type) {\r\n      case 'flashcard_created':\r\n        earned = activities.flashcards.length >= criteria.count\r\n        break\r\n\r\n      case 'study_streak':\r\n        // This would need more complex calculation based on study session dates\r\n        // For now, skip streak badges in backfill\r\n        break\r\n\r\n      case 'module_completed':\r\n        // Get module completions from enrollments\r\n        const { data: completions } = await supabaseClient\r\n          .from('enrollments')\r\n          .select('progress')\r\n          .eq('user_id', userId)\r\n        \r\n        const moduleCount = completions?.filter((e: any) => e.progress?.completed === true).length || 0\r\n        earned = moduleCount >= criteria.count\r\n        break\r\n\r\n      case 'reading_time':\r\n        const totalHours = activities.reading_sessions\r\n          .reduce((sum, session) => sum + (session.duration_seconds || 0), 0) / 3600\r\n        earned = totalHours >= criteria.hours\r\n        break\r\n    }\r\n\r\n    if (earned) {\r\n      await supabaseClient\r\n        .from('user_badges')\r\n        .insert({ user_id: userId, badge_id: badge.id })\r\n\r\n      newBadges.push(badge)\r\n    }\r\n  }\r\n\r\n  return newBadges\r\n}\r\n\r\nasync function backfillAllUsers(supabaseClient: any, dryRun: boolean): Promise<Response> {\r\n  // Get all users who have activities\r\n  const { data: activeUsers } = await supabaseClient\r\n    .from('profiles')\r\n    .select('id')\r\n    .not('id', 'is', null)\r\n\r\n  const results: BackfillResult[] = []\r\n  \r\n  for (const user of activeUsers || []) {\r\n    try {\r\n      const userResult = await backfillUserXP(supabaseClient, user.id, dryRun)\r\n      const userResultData = await userResult.json()\r\n      results.push(userResultData)\r\n    } catch (error) {\r\n      console.error(`Error processing user ${user.id}:`, error)\r\n      results.push({\r\n        user_id: user.id,\r\n        before_xp: 0,\r\n        after_xp: 0,\r\n        before_level: 1,\r\n        after_level: 1,\r\n        events_created: 0,\r\n        badges_awarded: [],\r\n        activities_processed: {\r\n          flashcards: 0,\r\n          study_sessions: 0,\r\n          notes: 0,\r\n          goals: 0,\r\n          reading_sessions: 0,\r\n          file_uploads: 0\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  const summary = {\r\n    dry_run: dryRun,\r\n    users_processed: results.length,\r\n    total_xp_awarded: results.reduce((sum, r) => sum + (r.after_xp - r.before_xp), 0),\r\n    total_events_created: results.reduce((sum, r) => sum + r.events_created, 0),\r\n    total_badges_awarded: results.reduce((sum, r) => sum + r.badges_awarded.length, 0),\r\n    results: results\r\n  }\r\n\r\n  return new Response(JSON.stringify(summary), {\r\n    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n  })\r\n}\r\n\r\nasync function rollbackBackfill(supabaseClient: any, userId: string): Promise<Response> {\r\n  console.log(`Rolling back XP backfill for user ${userId}`)\r\n\r\n  // Delete all backfill XP events\r\n  const { data: deletedEvents, error: deleteError } = await supabaseClient\r\n    .from('xp_events')\r\n    .delete()\r\n    .eq('user_id', userId)\r\n    .contains('metadata', { backfill: true })\r\n    .select()\r\n\r\n  if (deleteError) {\r\n    throw deleteError\r\n  }\r\n\r\n  // Recalculate totals after rollback\r\n  const { data: remainingEvents } = await supabaseClient\r\n    .from('xp_events')\r\n    .select('event_value')\r\n    .eq('user_id', userId)\r\n\r\n  const newTotalXP = remainingEvents?.reduce((sum: number, event: any) => sum + event.event_value, 0) || 0\r\n\r\n  // Calculate new level\r\n  const { data: levelData } = await supabaseClient.rpc('calculate_level_from_xp', {\r\n    total_xp: newTotalXP\r\n  })\r\n\r\n  const newLevel = levelData?.[0]?.level || 1\r\n  const nextLevelXP = levelData?.[0]?.next_level_xp || 100\r\n\r\n  // Update user XP record\r\n  await supabaseClient\r\n    .from('user_xp')\r\n    .upsert({\r\n      user_id: userId,\r\n      total_xp: newTotalXP,\r\n      level: newLevel,\r\n      next_level_xp: nextLevelXP\r\n    })\r\n\r\n  // Update profile\r\n  await supabaseClient\r\n    .from('profiles')\r\n    .update({ total_xp: newTotalXP })\r\n    .eq('id', userId)\r\n\r\n  return new Response(JSON.stringify({\r\n    user_id: userId,\r\n    events_deleted: deletedEvents?.length || 0,\r\n    new_total_xp: newTotalXP,\r\n    new_level: newLevel,\r\n    message: 'Backfill rollback completed successfully'\r\n  }), {\r\n    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n  })\r\n}\r\n\r\nasync function getBackfillReport(supabaseClient: any, userId: string): Promise<Response> {\r\n  const { data: userXP } = await supabaseClient\r\n    .from('user_xp')\r\n    .select('*')\r\n    .eq('user_id', userId)\r\n    .single()\r\n\r\n  const { data: xpEvents } = await supabaseClient\r\n    .from('xp_events')\r\n    .select('*')\r\n    .eq('user_id', userId)\r\n    .order('created_at', { ascending: false })\r\n\r\n  const { data: userBadges } = await supabaseClient\r\n    .from('user_badges')\r\n    .select('*, badges(*)')\r\n    .eq('user_id', userId)\r\n\r\n  const backfillEvents = xpEvents?.filter((e: any) => e.metadata?.backfill === true) || []\r\n  const regularEvents = xpEvents?.filter((e: any) => e.metadata?.backfill !== true) || []\r\n\r\n  return new Response(JSON.stringify({\r\n    user_id: userId,\r\n    current_xp: userXP?.total_xp || 0,\r\n    current_level: userXP?.level || 1,\r\n    total_events: xpEvents?.length || 0,\r\n    backfill_events: backfillEvents.length,\r\n    regular_events: regularEvents.length,\r\n    backfill_xp: backfillEvents.reduce((sum: number, e: any) => sum + e.event_value, 0),\r\n    regular_xp: regularEvents.reduce((sum: number, e: any) => sum + e.event_value, 0),\r\n    badges_earned: userBadges?.length || 0,\r\n    recent_events: xpEvents?.slice(0, 10) || []\r\n  }), {\r\n    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n  })\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jashon\\OneDrive\\Documents\\GitHub\\fpk-learner-v1\\supabase\\functions\\xp-system\\index.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'fetchError' is never reassigned. Use 'const' instead.","line":103,"column":30,"nodeType":"Identifier","messageId":"useConst","endLine":103,"endColumn":40},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":217,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":220,"endColumn":33,"suggestions":[{"messageId":"addBrackets","fix":{"range":[6574,6804],"text":"{ const { count: flashcardCount } = await supabaseClient\r\n          .from('flashcards')\r\n          .select('id', { count: 'exact' })\r\n          .eq('user_id', userId)\r\n        earned = flashcardCount >= criteria.count\r\n        break }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":225,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":230,"endColumn":20,"suggestions":[{"messageId":"addBrackets","fix":{"range":[6844,7137],"text":"{ const { data: studyStreak } = await supabaseClient\r\n          .from('streaks')\r\n          .select('current_count')\r\n          .eq('user_id', userId)\r\n          .eq('streak_type', 'study')\r\n          .single()\r\n        earned = (studyStreak?.current_count || 0) >= criteria.count\r\n        break }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":235,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":239,"endColumn":53,"suggestions":[{"messageId":"addBrackets","fix":{"range":[7181,7466],"text":"{ const { count: moduleCount } = await supabaseClient\r\n          .from('enrollments')\r\n          .select('progress', { count: 'exact' })\r\n          .eq('user_id', userId)\r\n          .contains('progress', { completed: true })\r\n        earned = moduleCount >= criteria.count\r\n        break }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":244,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":247,"endColumn":33,"suggestions":[{"messageId":"addBrackets","fix":{"range":[7506,7870],"text":"{ const { data: readingSessions } = await supabaseClient\r\n          .from('reading_sessions')\r\n          .select('duration_seconds')\r\n          .eq('user_id', userId)\r\n        const totalHours = (readingSessions || [])\r\n          .reduce((sum, session) => sum + (session.duration_seconds || 0), 0) / 3600\r\n        earned = totalHours >= criteria.hours\r\n        break }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":248,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":249,"endColumn":85,"suggestions":[{"messageId":"addBrackets","fix":{"range":[7506,7870],"text":"{ const { data: readingSessions } = await supabaseClient\r\n          .from('reading_sessions')\r\n          .select('duration_seconds')\r\n          .eq('user_id', userId)\r\n        const totalHours = (readingSessions || [])\r\n          .reduce((sum, session) => sum + (session.duration_seconds || 0), 0) / 3600\r\n        earned = totalHours >= criteria.hours\r\n        break }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { serve } from \"https://deno.land/std@0.168.0/http/server.ts\"\r\nimport { createClient } from \"https://esm.sh/@supabase/supabase-js@2\"\r\n\r\nconst corsHeaders = {\r\n  'Access-Control-Allow-Origin': '*',\r\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\r\n}\r\n\r\ninterface XPEvent {\r\n  event_type: string;\r\n  event_value: number;\r\n  metadata?: any;\r\n}\r\n\r\ninterface BadgeCheck {\r\n  badge_id: string;\r\n  criteria: any;\r\n}\r\n\r\nserve(async (req) => {\r\n  if (req.method === 'OPTIONS') {\r\n    return new Response(null, { headers: corsHeaders });\r\n  }\r\n\r\n  try {\r\n    const supabaseClient = createClient(\r\n      Deno.env.get('SUPABASE_URL') ?? '',\r\n      Deno.env.get('SUPABASE_ANON_KEY') ?? '',\r\n      {\r\n        global: {\r\n          headers: { Authorization: req.headers.get('Authorization')! },\r\n        },\r\n      }\r\n    )\r\n\r\n    const { data: { user } } = await supabaseClient.auth.getUser()\r\n    if (!user) {\r\n      return new Response('Unauthorized', { status: 401, headers: corsHeaders })\r\n    }\r\n\r\n    const { action, ...payload } = await req.json()\r\n\r\n    switch (action) {\r\n      case 'award_xp':\r\n        return await awardXP(supabaseClient, user.id, payload)\r\n      case 'get_user_stats':\r\n        return await getUserStats(supabaseClient, user.id)\r\n      case 'check_badges':\r\n        return await checkAndAwardBadges(supabaseClient, user.id)\r\n      case 'update_streak':\r\n        return await updateStreak(supabaseClient, user.id, payload.streak_type)\r\n      case 'get_leaderboard':\r\n        return await getLeaderboard(supabaseClient, payload.limit || 10)\r\n      case 'purchase_item':\r\n        return await purchaseShopItem(supabaseClient, user.id, payload.item_id)\r\n      default:\r\n        return new Response('Invalid action', { status: 400, headers: corsHeaders })\r\n    }\r\n  } catch (error) {\r\n    console.error('XP System Error:', error)\r\n    return new Response(JSON.stringify({ error: error.message }), {\r\n      status: 500,\r\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n    })\r\n  }\r\n})\r\n\r\nasync function awardXP(supabaseClient: any, userId: string, payload: XPEvent) {\r\n  console.log(`Awarding ${payload.event_value} XP for ${payload.event_type}`)\r\n\r\n  // Check for active quests and apply multipliers\r\n  const { data: activeQuests } = await supabaseClient\r\n    .from('quests')\r\n    .select('*')\r\n    .eq('is_active', true)\r\n    .lte('start_date', new Date().toISOString())\r\n    .gte('end_date', new Date().toISOString())\r\n\r\n  let multiplier = 1.0\r\n  for (const quest of activeQuests || []) {\r\n    const criteria = quest.criteria as any\r\n    if (criteria.activity_types?.includes(payload.event_type)) {\r\n      multiplier = Math.max(multiplier, quest.xp_multiplier)\r\n    }\r\n  }\r\n\r\n  const finalXP = Math.round(payload.event_value * multiplier)\r\n\r\n  // Record XP event\r\n  const { error: eventError } = await supabaseClient\r\n    .from('xp_events')\r\n    .insert({\r\n      user_id: userId,\r\n      event_type: payload.event_type,\r\n      event_value: finalXP,\r\n      metadata: { ...payload.metadata, multiplier }\r\n    })\r\n\r\n  if (eventError) throw eventError\r\n\r\n  // Get or create user XP record\r\n  let { data: userXP, error: fetchError } = await supabaseClient\r\n    .from('user_xp')\r\n    .select('*')\r\n    .eq('user_id', userId)\r\n    .single()\r\n\r\n  if (fetchError && fetchError.code === 'PGRST116') {\r\n    // Create new user XP record\r\n    const { data: newUserXP, error: createError } = await supabaseClient\r\n      .from('user_xp')\r\n      .insert({ user_id: userId, total_xp: 0, level: 1, next_level_xp: 100 })\r\n      .select()\r\n      .single()\r\n\r\n    if (createError) throw createError\r\n    userXP = newUserXP\r\n  } else if (fetchError) {\r\n    throw fetchError\r\n  }\r\n\r\n  // Calculate new totals\r\n  const newTotalXP = userXP.total_xp + finalXP\r\n  \r\n  // Calculate new level\r\n  const { data: levelData } = await supabaseClient.rpc('calculate_level_from_xp', {\r\n    total_xp: newTotalXP\r\n  })\r\n\r\n  const { level: newLevel, next_level_xp: xpToNext } = levelData[0]\r\n  const leveledUp = newLevel > userXP.level\r\n\r\n  // Update user XP\r\n  const { error: updateError } = await supabaseClient\r\n    .from('user_xp')\r\n    .update({\r\n      total_xp: newTotalXP,\r\n      level: newLevel,\r\n      next_level_xp: xpToNext\r\n    })\r\n    .eq('user_id', userId)\r\n\r\n  if (updateError) throw updateError\r\n\r\n  // Update profile total_xp for compatibility\r\n  await supabaseClient\r\n    .from('profiles')\r\n    .update({ total_xp: newTotalXP })\r\n    .eq('id', userId)\r\n\r\n  // Check for new badges if leveled up\r\n  let newBadges = []\r\n  if (leveledUp) {\r\n    const badgeResponse = await checkAndAwardBadges(supabaseClient, userId)\r\n    const badgeData = await badgeResponse.json()\r\n    newBadges = badgeData.newBadges || []\r\n  }\r\n\r\n  return new Response(JSON.stringify({\r\n    success: true,\r\n    xp_awarded: finalXP,\r\n    total_xp: newTotalXP,\r\n    level: newLevel,\r\n    xp_to_next: xpToNext,\r\n    leveled_up: leveledUp,\r\n    multiplier: multiplier,\r\n    new_badges: newBadges\r\n  }), {\r\n    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n  })\r\n}\r\n\r\nasync function getUserStats(supabaseClient: any, userId: string) {\r\n  const [userXPResponse, badgesResponse, streaksResponse] = await Promise.all([\r\n    supabaseClient.from('user_xp').select('*').eq('user_id', userId).single(),\r\n    supabaseClient.from('user_badges').select('*, badges(*)').eq('user_id', userId),\r\n    supabaseClient.from('streaks').select('*').eq('user_id', userId)\r\n  ])\r\n\r\n  const userXP = userXPResponse.data || { total_xp: 0, level: 1, next_level_xp: 100 }\r\n  const badges = badgesResponse.data || []\r\n  const streaks = streaksResponse.data || []\r\n\r\n  return new Response(JSON.stringify({\r\n    xp: userXP,\r\n    badges: badges,\r\n    streaks: streaks\r\n  }), {\r\n    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n  })\r\n}\r\n\r\nasync function checkAndAwardBadges(supabaseClient: any, userId: string) {\r\n  // Get all available badges\r\n  const { data: allBadges } = await supabaseClient\r\n    .from('badges')\r\n    .select('*')\r\n\r\n  // Get user's current badges\r\n  const { data: userBadges } = await supabaseClient\r\n    .from('user_badges')\r\n    .select('badge_id')\r\n    .eq('user_id', userId)\r\n\r\n  const earnedBadgeIds = new Set(userBadges?.map(ub => ub.badge_id) || [])\r\n  const newBadges = []\r\n\r\n  for (const badge of allBadges || []) {\r\n    if (earnedBadgeIds.has(badge.id)) continue\r\n\r\n    const criteria = badge.criteria as any\r\n    let earned = false\r\n\r\n    switch (criteria.type) {\r\n      case 'flashcard_created':\r\n        const { count: flashcardCount } = await supabaseClient\r\n          .from('flashcards')\r\n          .select('id', { count: 'exact' })\r\n          .eq('user_id', userId)\r\n        earned = flashcardCount >= criteria.count\r\n        break\r\n\r\n      case 'study_streak':\r\n        const { data: studyStreak } = await supabaseClient\r\n          .from('streaks')\r\n          .select('current_count')\r\n          .eq('user_id', userId)\r\n          .eq('streak_type', 'study')\r\n          .single()\r\n        earned = (studyStreak?.current_count || 0) >= criteria.count\r\n        break\r\n\r\n      case 'module_completed':\r\n        const { count: moduleCount } = await supabaseClient\r\n          .from('enrollments')\r\n          .select('progress', { count: 'exact' })\r\n          .eq('user_id', userId)\r\n          .contains('progress', { completed: true })\r\n        earned = moduleCount >= criteria.count\r\n        break\r\n\r\n      case 'reading_time':\r\n        const { data: readingSessions } = await supabaseClient\r\n          .from('reading_sessions')\r\n          .select('duration_seconds')\r\n          .eq('user_id', userId)\r\n        const totalHours = (readingSessions || [])\r\n          .reduce((sum, session) => sum + (session.duration_seconds || 0), 0) / 3600\r\n        earned = totalHours >= criteria.hours\r\n        break\r\n    }\r\n\r\n    if (earned) {\r\n      await supabaseClient\r\n        .from('user_badges')\r\n        .insert({ user_id: userId, badge_id: badge.id })\r\n\r\n      // Award badge XP\r\n      if (badge.xp_reward > 0) {\r\n        await awardXP(supabaseClient, userId, {\r\n          event_type: 'badge_earned',\r\n          event_value: badge.xp_reward,\r\n          metadata: { badge_id: badge.badge_id }\r\n        })\r\n      }\r\n\r\n      newBadges.push(badge)\r\n    }\r\n  }\r\n\r\n  return new Response(JSON.stringify({ newBadges }), {\r\n    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n  })\r\n}\r\n\r\nasync function updateStreak(supabaseClient: any, userId: string, streakType: string) {\r\n  const today = new Date().toISOString().split('T')[0]\r\n  \r\n  const { data: streak, error } = await supabaseClient\r\n    .from('streaks')\r\n    .select('*')\r\n    .eq('user_id', userId)\r\n    .eq('streak_type', streakType)\r\n    .single()\r\n\r\n  if (error && error.code === 'PGRST116') {\r\n    // Create new streak\r\n    const { data: newStreak, error: createError } = await supabaseClient\r\n      .from('streaks')\r\n      .insert({\r\n        user_id: userId,\r\n        streak_type: streakType,\r\n        start_date: today,\r\n        current_count: 1,\r\n        best_count: 1,\r\n        last_activity_date: today\r\n      })\r\n      .select()\r\n      .single()\r\n\r\n    if (createError) throw createError\r\n    \r\n    // Award streak XP\r\n    await awardXP(supabaseClient, userId, {\r\n      event_type: 'streak_started',\r\n      event_value: 5,\r\n      metadata: { streak_type: streakType }\r\n    })\r\n\r\n    return new Response(JSON.stringify(newStreak), {\r\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n    })\r\n  }\r\n\r\n  if (error) throw error\r\n\r\n  const lastActivity = new Date(streak.last_activity_date)\r\n  const todayDate = new Date(today)\r\n  const diffDays = Math.floor((todayDate.getTime() - lastActivity.getTime()) / (1000 * 60 * 60 * 24))\r\n\r\n  let newCount = streak.current_count\r\n  let newBest = streak.best_count\r\n  let newStart = streak.start_date\r\n\r\n  if (diffDays === 0) {\r\n    // Same day, no change\r\n    return new Response(JSON.stringify(streak), {\r\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n    })\r\n  } else if (diffDays === 1) {\r\n    // Consecutive day\r\n    newCount += 1\r\n    newBest = Math.max(newBest, newCount)\r\n    \r\n    // Award streak XP\r\n    await awardXP(supabaseClient, userId, {\r\n      event_type: 'streak_continued',\r\n      event_value: Math.min(newCount, 10), // Cap at 10 XP per day\r\n      metadata: { streak_type: streakType, count: newCount }\r\n    })\r\n  } else {\r\n    // Streak broken\r\n    newCount = 1\r\n    newStart = today\r\n    \r\n    await awardXP(supabaseClient, userId, {\r\n      event_type: 'streak_restarted',\r\n      event_value: 5,\r\n      metadata: { streak_type: streakType }\r\n    })\r\n  }\r\n\r\n  const { data: updatedStreak, error: updateError } = await supabaseClient\r\n    .from('streaks')\r\n    .update({\r\n      current_count: newCount,\r\n      best_count: newBest,\r\n      start_date: newStart,\r\n      last_activity_date: today\r\n    })\r\n    .eq('id', streak.id)\r\n    .select()\r\n    .single()\r\n\r\n  if (updateError) throw updateError\r\n\r\n  return new Response(JSON.stringify(updatedStreak), {\r\n    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n  })\r\n}\r\n\r\nasync function getLeaderboard(supabaseClient: any, limit: number) {\r\n  const { data: leaderboard, error } = await supabaseClient\r\n    .from('user_xp')\r\n    .select(`\r\n      user_id,\r\n      total_xp,\r\n      level,\r\n      profiles(display_name, full_name, avatar_url)\r\n    `)\r\n    .order('total_xp', { ascending: false })\r\n    .limit(limit)\r\n\r\n  if (error) throw error\r\n\r\n  return new Response(JSON.stringify(leaderboard), {\r\n    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n  })\r\n}\r\n\r\nasync function purchaseShopItem(supabaseClient: any, userId: string, itemId: string) {\r\n  // Get user's current XP\r\n  const { data: userXP, error: xpError } = await supabaseClient\r\n    .from('user_xp')\r\n    .select('total_xp')\r\n    .eq('user_id', userId)\r\n    .single()\r\n\r\n  if (xpError) throw xpError\r\n\r\n  // Get shop item\r\n  const { data: item, error: itemError } = await supabaseClient\r\n    .from('shop_items')\r\n    .select('*')\r\n    .eq('item_id', itemId)\r\n    .eq('is_available', true)\r\n    .single()\r\n\r\n  if (itemError) throw itemError\r\n\r\n  if (userXP.total_xp < item.xp_cost) {\r\n    return new Response(JSON.stringify({ error: 'Insufficient XP' }), {\r\n      status: 400,\r\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n    })\r\n  }\r\n\r\n  // Record purchase\r\n  const { error: purchaseError } = await supabaseClient\r\n    .from('user_purchases')\r\n    .insert({\r\n      user_id: userId,\r\n      shop_item_id: item.id,\r\n      xp_spent: item.xp_cost\r\n    })\r\n\r\n  if (purchaseError) throw purchaseError\r\n\r\n  // Deduct XP\r\n  const newTotalXP = userXP.total_xp - item.xp_cost\r\n  const { error: updateError } = await supabaseClient\r\n    .from('user_xp')\r\n    .update({ total_xp: newTotalXP })\r\n    .eq('user_id', userId)\r\n\r\n  if (updateError) throw updateError\r\n\r\n  return new Response(JSON.stringify({\r\n    success: true,\r\n    item_purchased: item,\r\n    xp_spent: item.xp_cost,\r\n    remaining_xp: newTotalXP\r\n  }), {\r\n    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n  })\r\n}\r\n","usedDeprecatedRules":[]}]